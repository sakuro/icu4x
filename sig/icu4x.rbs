module ICU4X
  extend Dry::Configurable

  VERSION: String

  def self.default_provider: () -> DataProvider?
  def self.reset_default_provider!: () -> void

  class Error < StandardError
  end

  class LocaleError < Error
  end

  class DataError < Error
  end

  class DataGeneratorError < Error
  end

  class DataProvider
    def self.from_blob: (Pathname path, ?priority: :language | :region) -> DataProvider
  end

  class DataGenerator
    def self.export: (locales: Array[String], markers: Symbol | Array[String], format: Symbol, output: Pathname) -> void
    def self.available_markers: () -> Array[String]
  end

  class Locale
    def self.parse: (String locale_str) -> Locale
    def self.parse_posix: (String posix_str) -> Locale

    def language: () -> String?
    def script: () -> String?
    def region: () -> String?
    def extensions: () -> { unicode: Hash[String, String], transform: String?, private: Array[String] }
    def to_s: () -> String
    def inspect: () -> String
    def ==: (Locale other) -> bool
    def eql?: (Locale other) -> bool
    def hash: () -> Integer
  end

  type plural_category = :zero | :one | :two | :few | :many | :other
  type plural_rule_type = :cardinal | :ordinal

  class PluralRules
    def self.new: (Locale locale, ?provider: DataProvider, ?type: plural_rule_type) -> PluralRules

    def select: (Integer | Float number) -> plural_category
    def categories: () -> Array[plural_category]
    def resolved_options: () -> { locale: String, type: plural_rule_type }
  end

  type number_format_style = :decimal | :percent | :currency
  type rounding_mode = :ceil | :floor | :expand | :trunc | :half_ceil | :half_floor | :half_expand | :half_trunc | :half_even

  type date_style = :full | :long | :medium | :short
  type time_style = :full | :long | :medium | :short
  type datetime_calendar = :gregory | :japanese | :buddhist | :chinese | :hebrew | :islamic | :persian | :indian | :ethiopian | :coptic | :roc | :dangi

  class NumberFormat
    def self.new: (
      Locale locale,
      ?provider: DataProvider,
      ?style: number_format_style,
      ?currency: String,
      ?use_grouping: bool,
      ?minimum_integer_digits: Integer,
      ?minimum_fraction_digits: Integer,
      ?maximum_fraction_digits: Integer,
      ?rounding_mode: rounding_mode
    ) -> NumberFormat

    def format: (Integer | Float | BigDecimal number) -> String
    def resolved_options: () -> {
      locale: String,
      style: number_format_style,
      use_grouping: bool,
      ?currency: String,
      ?minimum_integer_digits: Integer,
      ?minimum_fraction_digits: Integer,
      ?maximum_fraction_digits: Integer,
      ?rounding_mode: rounding_mode
    }
  end

  class DateTimeFormat
    def self.new: (
      Locale locale,
      ?provider: DataProvider,
      ?date_style: date_style,
      ?time_style: time_style,
      ?time_zone: String,
      ?calendar: datetime_calendar
    ) -> DateTimeFormat

    def format: (Time time) -> String
    def resolved_options: () -> {
      locale: String,
      calendar: datetime_calendar,
      ?date_style: date_style,
      ?time_style: time_style,
      ?time_zone: String
    }
  end

  type relative_time_format_style = :long | :short | :narrow
  type relative_time_format_numeric = :always | :auto
  type relative_time_unit = :second | :minute | :hour | :day | :week | :month | :quarter | :year

  class RelativeTimeFormat
    def self.new: (
      Locale locale,
      ?provider: DataProvider,
      ?style: relative_time_format_style,
      ?numeric: relative_time_format_numeric
    ) -> RelativeTimeFormat

    def format: (Integer value, relative_time_unit unit) -> String
    def resolved_options: () -> {
      locale: String,
      style: relative_time_format_style,
      numeric: relative_time_format_numeric
    }
  end

  type list_format_type = :conjunction | :disjunction | :unit
  type list_format_style = :long | :short | :narrow

  type collator_sensitivity = :base | :accent | :case | :variant
  type collator_case_first = :upper | :lower

  class ListFormat
    def self.new: (
      Locale locale,
      ?provider: DataProvider,
      ?type: list_format_type,
      ?style: list_format_style
    ) -> ListFormat

    def format: (Array[String] list) -> String
    def resolved_options: () -> {
      locale: String,
      type: list_format_type,
      style: list_format_style
    }
  end

  class Collator
    def self.new: (
      Locale locale,
      ?provider: DataProvider,
      ?sensitivity: collator_sensitivity,
      ?numeric: bool,
      ?case_first: collator_case_first
    ) -> Collator

    def compare: (String a, String b) -> Integer
    def resolved_options: () -> {
      locale: String,
      sensitivity: collator_sensitivity,
      numeric: bool,
      ?case_first: collator_case_first
    }
  end

  type display_names_type = :language | :region | :script | :locale
  type display_names_style = :long | :short | :narrow
  type display_names_fallback = :code | :none

  class DisplayNames
    def self.new: (
      Locale locale,
      ?provider: DataProvider,
      type: display_names_type,
      ?style: display_names_style,
      ?fallback: display_names_fallback
    ) -> DisplayNames

    def of: (String code) -> String?
    def resolved_options: () -> {
      locale: String,
      type: display_names_type,
      style: display_names_style,
      fallback: display_names_fallback
    }
  end

  type segmenter_granularity = :grapheme | :word | :sentence | :line

  class Segmenter
    class Segment
      attr_reader segment: String
      attr_reader index: Integer

      def word_like?: () -> bool?
    end

    def self.new: (
      granularity: segmenter_granularity,
      ?provider: DataProvider
    ) -> Segmenter

    def segment: (String text) -> Array[Segment]
    def resolved_options: () -> { granularity: segmenter_granularity }
  end
end
