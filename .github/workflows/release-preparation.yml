name: Release Preparation

# This workflow only handles file updates for release preparation.
# All validations are performed by the Release Validation workflow on PR creation.

env:
  GEM_NAME: ${{ github.event.repository.name }}

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 1.0.0)'
        required: true
        type: string

jobs:
  create-release-branch:
    runs-on: ubuntu-latest
    permissions:
      contents: write       # Required for git push (branch and tag creation)
      pull-requests: write  # Required for PR creation

    steps:
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
        token: ${{ secrets.WORKFLOW_TOKEN }}

    - name: Set git user
      uses: git-actions/set-user@v1

    - name: Create release branch
      run: |
        git checkout -b release-v${{ github.event.inputs.version }}

    - name: Update version file
      run: |
        GEM_PATH="${{ env.GEM_NAME }}"
        GEM_PATH="${GEM_PATH//-//}"  # Convert hyphens to slashes for path
        sed -i 's/VERSION = ".*"/VERSION = "${{ github.event.inputs.version }}"/' "lib/$GEM_PATH/version.rb"

    - name: Generate CHANGELOG entries
      env:
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        TEMP_FILE: /tmp/changelog_entries_${{ github.run_id }}.txt
      run: |
        # Validate API key is set
        if [ -z "$ANTHROPIC_API_KEY" ]; then
          echo "::error::ANTHROPIC_API_KEY secret is not set"
          exit 1
        fi

        # Get the last release tag
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

        # Get commits since last tag (or all commits if no tag exists)
        if [ -n "$LAST_TAG" ]; then
          echo "Analyzing commits since $LAST_TAG"
          COMMITS=$(git log --format="- %s" "$LAST_TAG"..HEAD)
        else
          echo "No previous tag found, analyzing all commits"
          COMMITS=$(git log --format="- %s")
        fi

        # Extract existing [Unreleased] section content (preserve structure, only trim leading/trailing blank lines)
        EXISTING_CHANGELOG=$(awk '
          /^## \[Unreleased\]/ { found=1; next }
          /^## \[/ && found { exit }
          found { print }
        ' CHANGELOG.md | sed -e '/./,$!d' -e :a -e '/^\n*$/{$d;N;ba' -e '}')

        echo "Existing changelog entries:"
        echo "$EXISTING_CHANGELOG"

        # Skip if no commits to analyze and no existing entries
        if [ -z "$COMMITS" ] && [ -z "$EXISTING_CHANGELOG" ]; then
          echo "No commits or existing entries to analyze"
          echo "(no user-facing changes)" > "$TEMP_FILE"
          exit 0
        fi

        echo "Commits to analyze:"
        echo "$COMMITS"

        # Build the prompt for Claude
        PROMPT=$(cat <<'PROMPT_EOF'
        Generate a complete CHANGELOG section by analyzing git commits and existing changelog entries.

        Rules:
        1. Only include changes that affect end users (features, bug fixes, breaking changes, performance improvements)
        2. Exclude internal changes (refactoring, tests, CI/CD, documentation unless user-facing)
        3. Group entries by category: Added, Changed, Fixed, Removed, Deprecated, Security
        4. Each entry should be a concise description in imperative mood
        5. If a commit references an issue (e.g., #123, Fixes #123), include it in parentheses at the end
        6. Merge existing entries with new ones from commits - avoid duplicates
        7. Preserve existing entries that are still relevant, but may rephrase for consistency
        8. Output ONLY the markdown content (no explanations), starting with ### if there are entries
        9. If there are no user-facing changes, output exactly: (no user-facing changes)

        Example output:
        ### Added
        - Implement list formatting support (#42)

        ### Fixed
        - Fix memory leak in data provider (#88)

        PROMPT_EOF
        )

        # Build the full prompt with existing entries and commits
        FULL_PROMPT="$PROMPT"
        if [ -n "$EXISTING_CHANGELOG" ]; then
          FULL_PROMPT="$FULL_PROMPT

        Existing changelog entries (preserve and merge with commits):
        $EXISTING_CHANGELOG"
        fi

        if [ -n "$COMMITS" ]; then
          FULL_PROMPT="$FULL_PROMPT

        Git commits to analyze:
        $COMMITS"
        fi

        # Call Claude API (use jq -Rs for safe JSON escaping of prompt with special characters)
        RESPONSE=$(echo "$FULL_PROMPT" | jq -Rs '{
          model: "claude-sonnet-4-20250514",
          max_tokens: 1024,
          messages: [{
            role: "user",
            content: .
          }]
        }' | curl -s https://api.anthropic.com/v1/messages \
          -H "Content-Type: application/json" \
          -H "x-api-key: $ANTHROPIC_API_KEY" \
          -H "anthropic-version: 2023-06-01" \
          -d @-)

        # Check for API errors
        API_ERROR=$(echo "$RESPONSE" | jq -r '.error.message // empty')
        if [ -n "$API_ERROR" ]; then
          echo "::error::Claude API error: $API_ERROR"
          echo "API Response: $RESPONSE"
          exit 1
        fi

        # Extract the generated changelog entries
        CHANGELOG_ENTRIES=$(echo "$RESPONSE" | jq -r '.content[0].text // empty')

        if [ -z "$CHANGELOG_ENTRIES" ]; then
          echo "::error::Failed to extract changelog entries from API response"
          echo "API Response: $RESPONSE"
          exit 1
        fi

        echo "Generated CHANGELOG entries:"
        echo "$CHANGELOG_ENTRIES"

        # Save entries for the next step
        echo "$CHANGELOG_ENTRIES" > "$TEMP_FILE"

    - name: Update CHANGELOG.md
      env:
        TEMP_FILE: /tmp/changelog_entries_${{ github.run_id }}.txt
      run: |
        # Get current date in UTC (GitHub Actions runs in UTC timezone)
        RELEASE_DATE=$(date -u +%Y-%m-%d)
        VERSION="${{ github.event.inputs.version }}"

        # Read generated changelog entries
        CHANGELOG_ENTRIES=""
        if [ -f "$TEMP_FILE" ]; then
          CHANGELOG_ENTRIES=$(cat "$TEMP_FILE")
          rm -f "$TEMP_FILE"
        fi

        # Build the new release section
        if [ "$CHANGELOG_ENTRIES" = "(no user-facing changes)" ] || [ -z "$CHANGELOG_ENTRIES" ]; then
          NEW_SECTION="## [$VERSION] - $RELEASE_DATE

        No user-facing changes in this release."
        else
          NEW_SECTION="## [$VERSION] - $RELEASE_DATE

        $CHANGELOG_ENTRIES"
        fi

        # Replace [Unreleased] section with new release section and add new [Unreleased]
        # Handle both cases: [Unreleased] in middle of file and at end of file
        awk -v new_section="$NEW_SECTION" '
          /^## \[Unreleased\]/ {
            print "## [Unreleased]"
            print ""
            print new_section
            skip = 1
            next
          }
          /^## \[/ && skip {
            skip = 0
            print
            next
          }
          !skip { print }
        ' CHANGELOG.md > /tmp/changelog_new_${{ github.run_id }}.md
        mv /tmp/changelog_new_${{ github.run_id }}.md CHANGELOG.md

    - name: Commit changes
      run: |
        GEM_PATH="${{ env.GEM_NAME }}"
        GEM_PATH="${GEM_PATH//-//}"  # Convert hyphens to slashes for path
        git add "lib/$GEM_PATH/version.rb" CHANGELOG.md
        git commit -m "$(cat <<'EOF'
        :bookmark: Prepare release v${{ github.event.inputs.version }}

        - Update VERSION constant to ${{ github.event.inputs.version }}
        - Update CHANGELOG.md for release
        - Add new unreleased section for future changes
        EOF
        )"

    - name: Create release tag
      run: |
        git tag -a "v${{ github.event.inputs.version }}" \
          -m "Release v${{ github.event.inputs.version }}"

    - name: Push release branch and tag
      run: |
        git push -u origin release-v${{ github.event.inputs.version }}
        git push origin v${{ github.event.inputs.version }}

    - name: Check if first release
      id: check_first_release
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Check if any releases exist
        RELEASE_COUNT=$(gh release list --limit 1 --json name --jq 'length')
        if [ "$RELEASE_COUNT" -eq 0 ]; then
          echo "is_first_release=true" >> $GITHUB_OUTPUT
        else
          echo "is_first_release=false" >> $GITHUB_OUTPUT
        fi

    - name: Create Pull Request
      env:
        GH_TOKEN: ${{ secrets.WORKFLOW_TOKEN }}
      run: |
        # Generate PR body based on whether this is the first release
        if [ "${{ steps.check_first_release.outputs.is_first_release }}" = "true" ]; then
          # First release - include full setup checklist
          PR_BODY="$(cat <<'EOF'
        ## Summary

        Prepare for release v${{ github.event.inputs.version }}

        **Note**: This is the first release for this gem.

        ## Changes

        - Update VERSION constant to ${{ github.event.inputs.version }}
        - Update CHANGELOG.md with release date
        - Add new unreleased section for future development

        ## Quality Checks

        These checks will be performed automatically by CI and validation workflows:

        - RuboCop checks
        - All tests pass
        - Version format validation
        - CHANGELOG.md format validation

        ## Release Requirements Checklist

        Before merging this PR, ensure the following requirements are met:

        ### Trusted Publishing Setup
        - [ ] **Pending Trusted Publisher**: Create on RubyGems.org for OIDC authentication
        - [ ] Configure at: https://rubygems.org/oidc/pending_trusted_publishers
        - [ ] Required settings:
          - Gem name: `${{ env.GEM_NAME }}`
          - Repository owner: `${{ github.repository_owner }}`
          - Repository name: `${{ github.event.repository.name }}`
          - Workflow filename: `release-publish.yml`
          - Environment name: `release`
        - [ ] **Note**: Pending publisher will auto-convert to active publisher after first successful gem push

        **Note**: GitHub repository settings (workflow permissions, environment) are automatically configured by the initialization script.
        - [ ] Guide: https://guides.rubygems.org/trusted-publishing/releasing-gems/

        ### RubyGems.org Setup
        - [ ] **Gem name availability**: Verify `${{ env.GEM_NAME }}` is available or owned by you
        - [ ] **Account verified**: RubyGems.org account email verified and MFA enabled (recommended)
        - [ ] **MFA Compatibility**: Trusted Publishing works seamlessly with MFA enabled
        - [ ] Configure MFA at: https://rubygems.org/profile/edit
        - [ ] **Note**: With Trusted Publishing, you can safely use "UI and API" MFA level without breaking CI/CD
        - [ ] MFA setup guide: https://guides.rubygems.org/setting-up-multifactor-authentication/

        ## Post-Merge Actions

        After merging this PR, the release workflow will automatically:
        - Use the git tag v${{ github.event.inputs.version }} (already created on this branch)
        - Build and publish gem to RubyGems from the tagged commit
        - Create GitHub release with assets

        EOF
        )"
        else
          # Subsequent release - simplified checklist
          PR_BODY="$(cat <<'EOF'
        ## Summary

        Prepare for release v${{ github.event.inputs.version }}

        ## Changes

        - Update VERSION constant to ${{ github.event.inputs.version }}
        - Update CHANGELOG.md with release date
        - Add new unreleased section for future development

        ## Quality Checks

        These checks will be performed automatically by CI and validation workflows:

        - RuboCop checks
        - All tests pass
        - Version format validation
        - CHANGELOG.md format validation

        ## Release Requirements Checklist

        Before merging this PR, ensure the following requirements are met:

        - [ ] **CHANGELOG.md**: Verify all notable changes are documented
        - [ ] **Breaking changes**: If any, ensure they are clearly documented in CHANGELOG
        - [ ] **Dependencies**: Check if any dependency updates are needed
        - [ ] **Documentation**: Ensure README and docs reflect any new features or changes

        ## Post-Merge Actions

        After merging this PR, the release workflow will automatically:
        - Use the git tag v${{ github.event.inputs.version }} (already created on this branch)
        - Build and publish gem to RubyGems from the tagged commit
        - Create GitHub release with assets

        EOF
        )"
        fi

        # Create PR with the appropriate body
        gh pr create \
          --title ":bookmark: Release v${{ github.event.inputs.version }}" \
          --body "$PR_BODY"
